%17.10.2024, lecture 3

\section{Public-Key Encryption Schemes}

Consider a scenario in which Alice holds both a public key and a private (secret) key.
Alice wishes to send a message to Bob over a communication channel that is monitored by an adversary, Eve.
Our goal is to ensure that Eve cannot decrypt the message, even though she may observe numerous communications (and potentially some plaintext messages).

We know that one-way functions are difficult to invert in general.
However, what if an adversary attempts to invert only a single bit of the output of a one-way function?
This question introduces the concept of \emph{hardcore predicates}.

\begin{definition}
    A family of polynomial-time computable functions $B_n \colon \{0, 1\}^n \to \{0, 1\}$ is a \emph{hardcore predicate} for a function $f_n \colon \{0, 1\}^n \to \{0, 1\}^s$ if no adversary can guess $B_n(x)$ given $f_n(x)$ with probability that is non-negligibly better than $\frac{1}{2}$:
    \[
        \forall k \; \forall A \; \exists N \; \forall n > N \; \Pr[A(f_n(x)) = B_n(x)] < \frac{1}{2} + \frac{1}{n^{k}},
    \]
    where $A$ is a randomized polynomial-time adversary.
    The probability is taken over $x \in U_n$ and the randomness used by $A$.
    See \Cref{fig:hardcore_predicate}.
    
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[>=Stealth, node distance=3cm, thick]
            \node (x) at (0,0) {$x$};
            \node (fx) at (3,0) {$f(x)$};
            \node (bx) at (0,-2) {$B(x)$};
            \draw[->, green] (x) -- (fx);
            \draw[->, green] (x) -- (bx);
            \draw[<-, dashed, red] (bx) -- (fx);
        \end{tikzpicture}
        \caption{From $x$, we can obtain both $f(x)$ and $B(x)$, but from $f(x)$, we cannot compute $B(x)$.}
        \label{fig:hardcore_predicate}
    \end{figure}
\end{definition}

\begin{restatable}[Oded Goldreich, Leonid Levin]{theorem}{goldreichlevin} \label{thm:goldreich_levin}
	If $f$ is a strongly one-way function, then the function $\tilde{f}(x, r) = (f(x), r)$ is also a strongly one-way function, and $B(x, r) = x_1 r_1 \oplus x_2 r_2 \oplus \dots$ is its hardcore predicate (where $r$ represents additional bits with $|r| = |x|$).
\end{restatable}

\begin{proof}
    The proof is postponed; see \Cref{proof:goldreich_levin}.
\end{proof}

\begin{exercise}
    The construction above also applies to families of trapdoor permutations.
    Formulate and prove this result.
\end{exercise}

\begin{problem}
    Note that the theorem does not claim the existence of a hardcore predicate for $f$ alone.
    Is it possible to construct one?
\end{problem}

\begin{algorithm}[Public-Key Encryption Scheme]
All algorithms below operate in time polynomial in $n$.
They may be randomized or deterministic.

\begin{itemize}
    \item $G$ (Alice) generates a pair of keys (a public key \pk\ and a secret/private key \sk):
    \[
    G: (1^n, r_g) \mapsto (\pk, \sk),
    \]
    where $r_g \in \{0,1\}^*$ is a random string privately used by $G$.
    \item $E$ (Bob) encrypts a one-bit message $\m$ using the public key: $\ct \coloneqq E(\pk, \m)$.
    \item $D$ (Alice) decrypts a one-bit message $\m$ using the secret key: $D(\sk, \ct) \approx \m$.
    
    We assume that the message is decrypted correctly:
    \[
    D(\sk, E(\pk, \m)) = \m,
    \]
    or at least that
    \[
        \Pr[ D(\sk, E(\pk, \m)) = \m ] \geq 0.9.
    \]
    \item An adversary $A(\pk, \ct)$ (Eve) should not be able to decrypt (without $\sk$) with a non-negligible probability, that is,
    \[
        \Pr\{ A(\pk, E(\pk, \m)) = \m \} < \underbrace{\epsilon(n)}_{\text{negligible}}.
    \]
\end{itemize}
\end{algorithm}

We denote a Public-Key Encryption Scheme as \emph{PKES}.
Additionally, we use the notation \emph{PKCS}.

\subsection{Public-Key Encryption from Hardcore Predicate}
One can construct a public-key encryption scheme using either a hardcore predicate or trapdoor permutations.
Assume that $G$ generates a trapdoor permutation family via a deterministic polynomial-time algorithm $G \colon (1^{n}, r_g) \mapsto (e, d, s)$ (Boolean circuits) such that:
\begin{itemize}
    \item $e \colon \{0,1\}^n \to \{0,1\}^{\xi(n)}$,
    \item $d \colon \{0,1\}^{\xi(n)} \to \{0,1\}^n$,
    \item $s \colon \{0,1\}^{\sigma(n)} \to \{0,1\}^n$,
\end{itemize}
with the property that, for all $x \in \text{Im}(s)$, we have $d(e(x)) = x$.
Then, if $B(x)$ is a hardcore predicate, $B(x)$ will be difficult to deduce from $e(x)$, where $x$ is some input generated using the sampler (we generate random bits and substitute them into the sampler).

The encryption scheme proceeds as follows:
\begin{itemize}
    \item \textbf{Key generation:} The public key is $\pk = (e, s)$, and the secret key is $\sk = d$.
    \item \textbf{Encryption:} $E(\pk, \m) = (e(s(r)), B(s(r)) \oplus \m)$, where $\m$ is the message bit.
    \item \textbf{Decryption:} $D(\sk, \ct) = B(d(\ct_1)) \oplus \ct_2$, where $\ct = (\ct_1, \ct_2)$ is the ciphertext.
\end{itemize}

\begin{lemma}
    If an adversary $A$ can break this encryption scheme, then it is possible to break the hardcore predicate.
\end{lemma}

We assume that the adversary, given the public key and an encryption of a message, can decrypt the message.

\begin{proof}
    Choose $b \in \{0, 1\}$ at random, and let $x = s(r)$ and $y = e(x)$.
    To break the hardcore predicate, we need to compute $B(x)$ from $y$.
    Define
    \[
        \beta \coloneqq A(\pk, (y, b)) \oplus b.
    \]
    Then,
    \begin{align*}
        \Pr[\beta = B(x)] &= \Pr[A(\pk, (y, b)) \oplus b = B(x)] \\
                          &= \Pr[A(\pk, (e(x), b)) \oplus b = B(x)] \\
                          &= \Pr[A(\pk, E(\pk, B(x) \oplus b)) \oplus b = B(x)] \\
                          &= \Pr[A(\pk, E(\pk, B(x) \oplus b)) = B(x) \oplus b].
    \end{align*}
    Thus, $\beta$ serves as a reliable guess for $B(x)$.
\end{proof}

\begin{exercise}
    We've shown that it is difficult to decrypt a random message bit.
    Is this level of difficulty sufficient for encryption security for large messages?
\end{exercise}

\subsection{Computational Indistinguishability}

\begin{definition}
	We say that probability distributions $P$ and $Q$ are \emph{computationally indistinguishable} if, for any integer $k$ and any adversary $A$ (typically a polynomial-time algorithm) which outputs 0 or 1,
	 \[
		 \left|\Pr_{x \sim P_n} [A(x) = 1] - \Pr_{x \sim Q_n} [A(x) = 1]\right| < \frac{1}{n^{k}}
	 \] 
	 for sufficiently large $n$.
	 Here, $P = \{P_n\}_{n \in \N} $ and $Q = \{Q_n\}_{n \in \N} $ are ensembles of distributions.
\end{definition}

\begin{definition}
	A PKCS is \emph{computationally indistinguishable} if, for all messages $(m_0, m_1)$ of polynomial length and all polynomial-time adversaries $A$,
	\begin{align*}
		\left|\Pr[A(E(m_0, e, r_e), e, 1^{n}, m_0, m_1) = 1] - \Pr[A(E(m_1, e, r_e), e, 1^{n}, m_0, m_1) = 1]\right| < \varepsilon(n),
	\end{align*}
	where the probability is taken over $r_g$, $r_e$, and the randomness used by $A$.
\end{definition}

\begin{theorem}
	For the 1-bit PKCS constructed, for any adversary $A$:
	 \[
		 \Pr[A(e(\m, r_e), 1^{n}, e) = \m] < \frac{1}{2} + \varepsilon(n),
	 \] 
	where $G(1^{n}, r_g) = (e, d)$, and $\Pr$ is taken over all random variables, including $\m$.
\end{theorem}

\begin{proof}
	This follows directly from \Cref{thm:goldreich_levin}.
\end{proof}

\begin{definition}
	A 1-bit PKCS is \emph{computationally indistinguishable} if, for all adversaries $A$,
	 \[
		 \left|\Pr[A(e(1, r_e), 1^{n}, e) = 1] - \Pr[A(e(0, r_e), 1^{n}, e) = 1]\right| < \varepsilon(n),
	 \] 
	where $G(1^{n}, r_g) = (e, d)$, and the probability is taken over all random variables, excluding $\m$.
\end{definition}

\begin{exercise}
	Is our PKCS computationally indistinguishable?
\end{exercise}

\subsection{Public-Key Encryption for Arbitrary-Length Messages}

Consider a naive approach.
Define $E^*(b_1b_2\ldots) = (E(b_1), E(b_2), \ldots)$ using the same key pair.

\begin{lemma}
	If there exists an adversary $A^*$ for $E^*$, then one can break the original 1-bit cryptosystem.
\end{lemma}

\begin{proof}
	Assume we are given $E(0)$ and $E(1)$ as two codewords, $\ct_a$ and $\ct_b$, and we need to distinguish between them.
	If $A^*$ can distinguish between some two messages $m_0 = s_1 \ldots s_p$ and $m_1 = t_1 \ldots t_p$, then we proceed as follows:
	\begin{align*}
		\frac{1}{n^{k}} < &\left|\Pr[A^*(E(s_1s_2\ldots s_{p-1}s_p)) = 1] - \Pr[A^*(E(t_1t_2\ldots t_{p-1}t_p)) = 1]\right| \leq \\
						  &\left| \Pr[A^*(E(s_1s_2\ldots s_{p - 1} s_p))] - \Pr[A^*(E(s_1 s_2 \ldots s_{p - 1} t_p))] \right| + \\
						  +&\left| \Pr[A^*(E(s_1s_2\ldots s_{p - 1} t_p))] - \Pr[A^*(E(s_1 s_2 \ldots s_{p - 2} t_{p - 1} t_p))] \right| + \\
						  &\ldots + \\
						  +&\left| \Pr[A^*(E(s_1t_2\ldots t_{p - 1} t_p))] - \Pr[A^*(E(t_1 t_2 \ldots t_{p - 1} t_p))] \right|.
	\end{align*}
	Thus, there exists some pair with a substantial difference:
	\[
		\Pr[A^*(E(s_1s_2\ldots s_{i_*} t_{i_* + 1}\ldots t_p)) = 1] - \Pr[A^*(E(s_1s_2\ldots s_{i_* - 1} t_{i_*} \ldots t_p)) = 1] > \frac{1}{n^{k'}}.
	\] 
	Since we do not know the value of $i_*$, we apply the following strategy.
	Take a random index $i$, and substitute $\ct_a$ for $s_{i}$ and $\ct_b$ for $t_{i}$, while assigning other bits at random.
	Thus, the overall success probability is at least:
	\[
		\Pr[i = i_*] \cdot \frac{1}{n^{k'}}.
	\] 
	Since $\Pr[i = i_*] = \frac{1}{p}$ and $p$ is polynomial, this probability is non-negligible.
\end{proof}

\subsection{Semantic Security}

Another approach to defining security is through \emph{semantic security}.
In this setting, rather than decrypting a message, the adversary attempts to compute some function of it.
For example, if a large document is sent, an adversary may try to extract specific crucial data from it.
Moreover, the adversary might possess some partial information about the message as a hint.
Additionally, the message itself is likely not an arbitrary string but a meaningful text, possibly generated by some probability distribution.

\begin{definition} \label{def:semantic_security}
	A PKCS is \emph{semantically secure} if, for any function $f$ (which the adversary aims to compute), any hint function $h$, any adversary $A$, and any message generator $M$, the following holds.
	Let $\tilde{A}$ be an adversary that tries to compute some function of the message without the code.
	We require that the two probabilities be close:
	 \[
		 \Pr[A(E(e, m), e, h(m)) = f(m)] \le  \Pr[\tilde{A}(e, h(m)) = f(m)] + \varepsilon(n),
	 \] 
	 where $h, f \in \fP$.
\end{definition}
Here, for $E$ we denote the encryption algorithm, and $e$ is the public code.

\begin{restatable}{theorem}{semanticsecurity} \label{thm:semantic_security}
	Semantic security $\iff$ computational indistinguishability.
\end{restatable}

\begin{proof}
	First, we prove that if a PKCS is semantically secure, then it is computationally indistinguishable.
	So, if we have an adversary $A_l$ that can distinguish encrypted $m_0, m_1$, then we can break PKCS.
	W.l.o.g. assume that pair $m_0, m_1$ has the best probability of success.
	Let's put $f(m_i) \coloneqq i$ (hence, function basically distinguished between $m_0, m_1$), we are not interested into other inputs of $f$.
	And let $h(x) = 0$ for any  $x$, so  $h$ gives no information.
	New adversary  $A_s$ uses $A_l$ for  $m_0, m_1$ (which are hardwired into the circuit $M_S$), which has success probability $> \frac{1}{2} + \delta$.
	Hence, $A_s$ breaks semantic security.

	Now, we will prove that if a PKCS is computationally indistinguishable, then it is semantically secure.
	Assume that some adversary $A_s$ can compute  $f(m)$, then we will show that it is not computationally indistinguishable.
	We will construct  $m_0, m_1$ with $f(m_0) \neq  f(m_1)$ that we will distinguish.
	New adversary $A_l$ given encrypted  $m$ distinguishes  $m$ which takes from set $\{m_0, m_1\} $ (each taken with probability $\frac{1}{2}$):
	\begin{itemize}
		\item If $A_s(E(e, m), e, h(m_0)) = f(m_0)$, then return 0.
		\item Otherwise, flip a fair coin and return the result.
	\end{itemize}
	Note, that we hardwired $f(m_0), h(m_0)$ into the circuit $A_l$.
\end{proof}

\subsection{More efficient PKCS}

For simplicity, let us denote $r$ as $s(r)$ (assuming that random bits are sampled according to the distribution of $s$).

Define $E^*(b_1 b_2 \ldots) = (E(b_1), E(b_2), \ldots)$, meaning that each bit has a separate codeword. Specifically,
\[
	E^*(b_1 b_2 \ldots) = \left(\left(\underbrace{e(r_1)}_{\approx n \text{ bits}}, B(r_1) \oplus b_1\right), \left(\underbrace{e(r_2)}_{\approx n \text{ bits}}, B(r_2) \oplus b_2\right), \ldots\right).
\] 

To improve upon this, consider:
\[
	E^{**}(b_1 \ldots b_m, e, r) = \left(e^{m}(r), B(r) \oplus b_1, B(e(r)) \oplus b_2, \ldots, B(e^{m - 1}(r)) \oplus b_m\right).
\] 
Later, we will show that these codewords are indistinguishable from codewords of a random message.
